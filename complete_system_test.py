#!/usr/bin/env python3 """ Complete Recommendation System Test with Real Redis Data Recommendation systemTest - GeneratetrueRedisnumber Author: Yang Liu """ import json import time import random import numpy as np import asyncio from typing import Dict, List, Any from datetime import datetime, timedelta from collections import defaultdict # mock/simulateRedisclass class MockRedis: def __init__(self): self.data = {} self.sorted_sets = {} self.hashes = {} self.lists = {} def set(self, key, value, ex=None): self.data[key] = {'value': value, 'expires': time.time() + ex if ex else None} return True def get(self, key): item = self.data.get(key) if item and (item['expires'] is None or item['expires'] > time.time()): return item['value'] return None def zadd(self, key, mapping): if key not in self.sorted_sets: self.sorted_sets[key] = {} self.sorted_sets[key].update(mapping) return len(mapping) def zrevrange(self, key, start, end, withscores=False): if key not in self.sorted_sets: return [] items = sorted(self.sorted_sets[key].items(), key=lambda x: x[1], reverse=True) result = items[start:end+1] if end >= 0 else items[start:] if withscores: return result return [item[0] for item in result] def zcard(self, key): return len(self.sorted_sets.get(key, {})) def hset(self, key, mapping=None, **kwargs): if key not in self.hashes: self.hashes[key] = {} if mapping: self.hashes[key].update(mapping) self.hashes[key].update(kwargs) return len(mapping) if mapping else len(kwargs) def hget(self, key, field): return self.hashes.get(key, {}).get(field) def hgetall(self, key): return self.hashes.get(key, {}) def lpush(self, key, *values): if key not in self.lists: self.lists[key] = [] self.lists[key] = list(values) + self.lists[key] return len(self.lists[key]) def lrange(self, key, start, end): if key not in self.lists: return [] return self.lists[key][start:end+1 if end >= 0 else None] def keys(self, pattern='*'): all_keys = (list(self.data.keys()) + list(self.sorted_sets.keys()) + list(self.hashes.keys()) + list(self.lists.keys())) return list(set(all_keys)) def type(self, key): if key in self.data: return 'string' elif key in self.sorted_sets: return 'zset' elif key in self.hashes: return 'hash' elif key in self.lists: return 'list' return 'none' class CompleteRecommendationSystemTest: """Recommendation systemTest""" def __init__(self): self.redis = MockRedis() self.users = [f"user_{i:04d}" for i in range(1, 1001)] #1000User self.items = [f"item_{i:05d}" for i in range(1, 5001)] #5000Product self.categories = list(range(1, 21)) #20individualclass self.brands = list(range(1, 51)) #50individual async def run_complete_test(self): """RunsystemTest""" print("ğŸš€ Recommendation systemTestStart/Begin") print("=" * 80) # 1. GenerateUserBehaviornumber print("\nğŸ“Š 1: GenerateUserBehaviornumber...") await self.generate_user_behavior_data() # 2. ExecuteRecallsegment (10000individualCandidates) print("\nğŸ¯ 2: ExecuteRecallsegment (10000Candidates)...") await self.execute_recall_stage() # 3. ExecuteCoarse rankingsegment (1000individualselect) print("\nğŸ”„ 3: ExecuteCoarse rankingsegment (1000select)...") await self.execute_coarse_ranking() # 4. ExecuteFine rankingsegment (100individualrecommend) print("\nâ­ 4: ExecuteFine rankingsegment (100recommend)...") await self.execute_fine_ranking() # 5. GenerateUserFeaturesCache print("\nğŸ‘¤ 5: GenerateUserFeaturesCache...") await self.generate_user_features() # 6. GenerateProductFeaturesCache print("\nğŸ›ï¸ 6: GenerateProductFeaturesCache...") await self.generate_item_features() # 7. GenerateEvaluationMetricsnumber print("\nğŸ“ˆ 7: GenerateEvaluationMetricsnumber...") await self.generate_evaluation_metrics() # 8. Redisnumberinner print("\nğŸ’¾ 8: Redisnumberinner...") await self.display_redis_data() print("\n" + "=" * 80) print("ğŸ‰ Recommendation systemTestComplete!") async def generate_user_behavior_data(self): """GenerateUserBehaviornumber""" current_time = time.time() for user in self.users[:50]: #Testfront50individualUser # UserInformation user_info = { 'user_id': user, 'age_group': random.randint(1, 6), 'gender': random.randint(0, 2), 'city_level': random.randint(1, 5), 'registration_date': current_time - random.randint(30, 365) * 24 * 3600, 'total_orders': random.randint(0, 50), 'total_amount': round(random.uniform(0, 5000), 2) } # StorageUserInformation self.redis.hset(f"user:{user}:profile", user_info) # GenerateUserBehavior num_actions = random.randint(10, 100) for _ in range(num_actions): item = random.choice(self.items) action = random.choices( ['view', 'click', 'add_cart', 'purchase', 'like', 'share'], weights=[50, 30, 10, 5, 3, 2] )[0] behavior_data = { 'user_id': user, 'item_id': item, 'action': action, 'timestamp': current_time - random.randint(0, 30*24*3600), #30dayinner 'session_id': f"session_{random.randint(1, 1000)}", 'duration': random.randint(10, 600) if action == 'view' else 0 } # StoragetoUserBehaviorList self.redis.lpush(f"user:{user}:behaviors", json.dumps(behavior_data)) print(f"âœ… Generate {len(self.users[:50])} individualUser Behaviornumber") async def execute_recall_stage(self): """ExecuteRecallsegment""" for user in self.users[:20]: #forfront20individualUserGenerateRecallresult # mock/simulateRecallalgorithmï¼ŒGenerate10000individualCandidatesProduct candidates = random.sample(self.items, min(len(self.items), 1000)) #actualGenerate1000individuallarge # forindividualCandidatesProductGenerateRecallminutenumber recall_scores = {} for item in candidates: score = random.uniform(0.1, 0.95) recall_scores[item] = score # StorageRecallresulttoRedis (sorted set) self.redis.zadd(f"recall:{user}:candidates", recall_scores) # SetthroughhourInformation self.redis.set(f"recall:{user}:timestamp", time.time(), ex=12*3600) print(f"âœ… for {len(self.users[:20])} individualUserGenerateRecallCandidates") async def execute_coarse_ranking(self): """ExecuteCoarse rankingsegment""" for user in self.users[:20]: # GetRecallCandidates candidates = self.redis.zrevrange(f"recall:{user}:candidates", 0, 999) #getfront1000individual if not candidates: continue # mock/simulateDeepFMCoarse rankingï¼Œnewminute coarse_scores = {} for item in candidates: # mock/simulateFeaturesCompute/CalculateandDeepFMPrediction base_score = random.uniform(0.1, 0.9) feature_boost = random.uniform(-0.1, 0.1) final_score = max(0.0, min(1.0, base_score + feature_boost)) coarse_scores[item] = final_score # selectTop1000Storage top_items = sorted(coarse_scores.items(), key=lambda x: x[1], reverse=True)[:1000] coarse_ranking = {item: score for item, score in top_items} # StorageCoarse rankingresult self.redis.zadd(f"coarse_rank:{user}:items", coarse_ranking) self.redis.set(f"coarse_rank:{user}:timestamp", time.time(), ex=6*3600) print(f"âœ… Complete {len(self.users[:20])} individualUser Coarse rankingProcess (1000select)") async def execute_fine_ranking(self): """ExecuteFine rankingsegment""" for user in self.users[:20]: # GetCoarse rankingresult coarse_items = self.redis.zrevrange(f"coarse_rank:{user}:items", 0, 99, withscores=True) if not coarse_items: continue # mock/simulateBERT4RecFine ranking fine_scores = {} for item, coarse_score in coarse_items: # mock/simulaterecommendModel sequence_score = random.uniform(0.05, 0.95) context_boost = random.uniform(-0.05, 0.05) final_score = max(0.0, min(1.0, sequence_score + context_boost)) fine_scores[item] = final_score # Storagemostendrecommendresult (Top100) self.redis.zadd(f"user:{user}:recommendations", fine_scores) self.redis.set(f"user:{user}:rec_timestamp", time.time(), ex=24*3600) # Generaterecommendation reason recommendations = [] for item, score in sorted(fine_scores.items(), key=lambda x: x[1], reverse=True)[:20]: reason = random.choice([ "based on History", "similarUser", "Popular/HotProductrecommend", "forselect", "based onPurchaserecord" ]) recommendations.append({ 'item_id': item, 'score': round(score, 4), 'reason': reason, 'category': random.choice(self.categories), 'predicted_ctr': round(random.uniform(0.01, 0.15), 4) }) # StoragerecommendInformation self.redis.set(f"recommendations:user:{user}:details", json.dumps(recommendations), ex=24*3600) print(f"âœ… Complete {len(self.users[:20])} individualUser Fine rankingProcess (100recommend)") async def generate_user_features(self): """GenerateUserFeaturesCache""" for user in self.users[:30]: # multipleTime windowStatistical features user_features = { # 1dayFeatures 'clicks_1d': random.randint(0, 20), 'views_1d': random.randint(0, 50), 'purchases_1d': random.randint(0, 3), 'browse_time_1d': random.randint(0, 3600), # 7dayFeatures 'clicks_7d': random.randint(0, 100), 'views_7d': random.randint(0, 200), 'purchases_7d': random.randint(0, 10), 'browse_time_7d': random.randint(0, 10800), # 30dayFeatures 'clicks_30d': random.randint(10, 500), 'views_30d': random.randint(20, 1000), 'purchases_30d': random.randint(1, 50), 'browse_time_30d': random.randint(1000, 50000), # Conversion rate (CVR)Features 'click_rate_7d': round(random.uniform(0.1, 0.8), 4), 'purchase_rate_7d': round(random.uniform(0.01, 0.3), 4), 'avg_order_value_30d': round(random.uniform(50, 500), 2), # goodFeatures 'preferred_categories': random.sample(self.categories, 3), 'preferred_brands': random.sample(self.brands, 2), 'activity_level': random.choice(['low', 'medium', 'high', 'super']), 'last_active_time': time.time() - random.randint(0, 7*24*3600) } # StorageUserFeatures self.redis.hset(f"features:user:{user}", user_features) print(f"âœ… Generate {len(self.users[:30])} individualUser FeaturesCache") async def generate_item_features(self): """GenerateProductFeaturesCache""" for item in self.items[:100]: item_features = { # attribute/property 'category_id': random.choice(self.categories), 'brand_id': random.choice(self.brands), 'price': round(random.uniform(10, 1000), 2), 'original_price': round(random.uniform(10, 1200), 2), # Statistical features 'views_1d': random.randint(0, 1000), 'clicks_1d': random.randint(0, 200), 'purchases_1d': random.randint(0, 50), 'views_7d': random.randint(50, 5000), 'clicks_7d': random.randint(10, 800), 'purchases_7d': random.randint(1, 200), 'views_30d': random.randint(200, 20000), 'clicks_30d': random.randint(50, 3000), 'purchases_30d': random.randint(5, 800), # Conversion rate (CVR) 'ctr_7d': round(random.uniform(0.01, 0.2), 4), 'cvr_7d': round(random.uniform(0.005, 0.1), 4), 'popularity_score': round(random.uniform(0.1, 0.95), 4), # inventoryand 'stock_count': random.randint(0, 1000), 'sales_velocity': round(random.uniform(0.1, 10.0), 2), 'avg_rating': round(random.uniform(3.0, 5.0), 2), 'review_count': random.randint(0, 500) } # StorageProductFeatures self.redis.hset(f"features:item:{item}", item_features) print(f"âœ… Generate {len(self.items[:100])} individualProduct FeaturesCache") async def generate_evaluation_metrics(self): """GenerateEvaluationMetricsnumber""" # systemMetrics system_metrics = { 'overall_ctr': round(random.uniform(0.02, 0.08), 4), 'overall_cvr': round(random.uniform(0.005, 0.03), 4), 'avg_session_duration': round(random.uniform(300, 1800), 1), 'daily_active_users': random.randint(8000, 12000), 'total_recommendations_served': random.randint(50000, 100000), 'cache_hit_rate': round(random.uniform(0.85, 0.95), 3), 'avg_response_time_ms': round(random.uniform(50, 150), 1), 'user_satisfaction_score': round(random.uniform(7.5, 9.2), 2) } self.redis.hset("system:metrics:realtime", system_metrics) # A/BTestresult ab_test_results = { 'test_name': 'bert4rec_vs_baseline', 'test_start_time': time.time() - 7*24*3600, 'control_ctr': 0.0245, 'treatment_ctr': 0.0287, 'improvement': '+17.1%', 'confidence': 0.95, 'sample_size_control': 10000, 'sample_size_treatment': 10000, 'status': 'significant_winner' } self.redis.set("ab_test:current_results", json.dumps(ab_test_results)) # UserwithdegreeMetrics engagement_metrics = { 'avg_items_per_session': round(random.uniform(5, 15), 1), 'like_rate': round(random.uniform(0.05, 0.15), 4), 'share_rate': round(random.uniform(0.01, 0.05), 4), 'add_cart_rate': round(random.uniform(0.08, 0.25), 4), 'return_user_rate_7d': round(random.uniform(0.3, 0.7), 3), 'avg_time_between_sessions': round(random.uniform(6, 48), 1) } self.redis.hset("engagement:metrics:current", engagement_metrics) print("âœ… GeneratesystemEvaluationMetricsnumber") async def display_redis_data(self): """Redisnumberinner""" print("\n" + "="*80) print("ğŸ’¾ Redis numberinner") print("="*80) # Getkey all_keys = self.redis.keys() print(f"\nğŸ“Š Redis :") print(f"totalKeynumberamount: {len(all_keys)}") # classmodelminuteclass key_stats = defaultdict(list) for key in all_keys: prefix = key.split(':')[0] if ':' in key else 'other' key_stats[prefix].append(key) print(f"\nğŸ—‚ï¸ numberminuteclass:") for prefix, keys in key_stats.items(): print(f"{prefix}: {len(keys)} individualkey") # classnumberkind print(f"\nğŸ” numberinnerkind:") print("-"*80) # 1. Userrecommendnumber user_rec_keys = [k for k in all_keys if k.startswith('user:') and ':recommendations' in k] if user_rec_keys: sample_key = user_rec_keys[0] user_id = sample_key.split(':')[1] recs = self.redis.zrevrange(sample_key, 0, 4, withscores=True) print(f"\nğŸ‘¤ UserrecommendCache ({sample_key}):") print("ProductID recommendminutenumber") for item, score in recs: print(f" {item:20} {score:.4f}") # 2. UserFeaturesnumber user_feature_keys = [k for k in all_keys if k.startswith('features:user:')] if user_feature_keys: sample_key = user_feature_keys[0] features = self.redis.hgetall(sample_key) print(f"\nğŸ“Š UserFeaturesCache ({sample_key}):") for key, value in list(features.items())[:8]: #front8individual print(f" {key:20}: {value}") # 3. ProductFeaturesnumber item_feature_keys = [k for k in all_keys if k.startswith('features:item:')] if item_feature_keys: sample_key = item_feature_keys[0] features = self.redis.hgetall(sample_key) print(f"\nğŸ›ï¸ ProductFeaturesCache ({sample_key}):") for key, value in list(features.items())[:8]: print(f" {key:20}: {value}") # 4. RecallCandidatesnumber recall_keys = [k for k in all_keys if k.startswith('recall:')] if recall_keys: sample_key = [k for k in recall_keys if ':candidates' in k][0] candidates = self.redis.zrevrange(sample_key, 0, 4, withscores=True) print(f"\nğŸ¯ RecallCandidatesCache ({sample_key}):") print("ProductID Recallminutenumber") for item, score in candidates: print(f" {item:20} {score:.4f}") # 5. systemMetricsnumber if 'system:metrics:realtime' in all_keys: metrics = self.redis.hgetall('system:metrics:realtime') print(f"\nğŸ“ˆ systemReal-timeMetrics:") for metric, value in metrics.items(): print(f" {metric:25}: {value}") # 6. recommendnumber detail_keys = [k for k in all_keys if k.startswith('recommendations:user:') and ':details' in k] if detail_keys: sample_key = detail_keys[0] details_json = self.redis.get(sample_key) if details_json: details = json.loads(details_json) print(f"\nğŸ¯ recommendnumber ({sample_key}):") print("ProductID minutenumber CTR") for item in details[:5]: print(f" {item['item_id']:12} {item['score']:.3f} {item['reason']:12} {item['predicted_ctr']:.3f}") # 7. A/BTestresult if 'ab_test:current_results' in all_keys: ab_result = json.loads(self.redis.get('ab_test:current_results')) print(f"\nğŸ§ª A/BTestresult:") print(f"Test: {ab_result['test_name']}") print(f"forgroupCTR: {ab_result['control_ctr']:.4f}") print(f"groupCTR: {ab_result['treatment_ctr']:.4f}") print(f"degree: {ab_result['improvement']}") print(f"degree: {ab_result['confidence']}") print(f"\n" + "="*80) print("ğŸ‰ RedisnumberCompleteï¼") print(f"âœ… Recommendation systemSuccessRunï¼ŒRediscontains {len(all_keys)} individualnumberkey") print(f"âœ… Userrecommendã€FeaturesCacheã€Recallresultã€systemMetricswaitInteger") print("="*80) async def main(): """mainTestfunction""" test_system = CompleteRecommendationSystemTest() await test_system.run_complete_test() if __name__ == "__main__": asyncio.run(main())