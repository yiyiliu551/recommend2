""" Multi-Time Window Statistical Features for Recommendation Systems multipleTime windowStatistical featuressystem - 1day/3day/7day/2week/1individualmonth Author: Yang Liu """ import time import json import redis import numpy as np from typing import Dict, List, Tuple, Optional, Any from dataclasses import dataclass, field from datetime import datetime, timedelta from collections import defaultdict, deque from enum import Enum import asyncio class TimeWindow(Enum): """Time windowdefinition""" ONE_DAY = "1d" #1day THREE_DAYS = "3d" #3day ONE_WEEK = "7d" #7day (1week) TWO_WEEKS = "14d" #14day (2week) ONE_MONTH = "30d" #30day (1individualmonth) @dataclass class UserBehaviorStats: """UserBehaviorStatistical features""" user_id: str window: TimeWindow timestamp: float # Behavior page_views: int = 0 #surfacenumber clicks: int = 0 #Clicknumber searches: int = 0 #searchnumber add_carts: int = 0 #Add to cartnumber purchases: int = 0 #Purchasenumber likes: int = 0 #pointnumber shares: int = 0 #Sharenumber # hour total_browse_time: int = 0 #totalhour(second) avg_session_duration: float = 0.0 #averageSessionhour max_session_duration: int = 0 #mostSessionhour # degreeBehavior unique_items_viewed: int = 0 #Productnumber unique_categories: int = 0 #classnumber repeat_purchases: int = 0 #copyPurchasenumber # Conversion rate (CVR)Metrics click_rate: float = 0.0 #Click-through rate (CTR) (clicks/page_views) cart_conversion_rate: float = 0.0 #Conversion rate (CVR) (add_carts/clicks) purchase_conversion_rate: float = 0.0 #PurchaseConversion rate (CVR) (purchases/clicks) # Userdegree active_days: int = 0 #daynumber active_sessions: int = 0 #Sessionnumber avg_daily_sessions: float = 0.0 #averagedailySessionnumber # cost total_amount: float = 0.0 #totalcost avg_order_value: float = 0.0 #averageorderpricevalue max_order_value: float = 0.0 #mostlargeorderpricevalue # Productgood preferred_categories: List[int] = field(default_factory=list) #goodclass preferred_brands: List[int] = field(default_factory=list) #good preferred_price_range: Tuple[float, float] = (0.0, 0.0) #goodprice @dataclass class ItemBehaviorStats: """ProductBehaviorStatistical features""" item_id: str window: TimeWindow timestamp: float # Impressionanddynamic exposures: int = 0 #Impressionnumber views: int = 0 #querynumber clicks: int = 0 #Clicknumber add_carts: int = 0 #Add to cartnumber purchases: int = 0 #Purchasenumber likes: int = 0 #pointnumber shares: int = 0 #Sharenumber # Userdegree unique_viewers: int = 0 #visitornumber unique_buyers: int = 0 #number repeat_buyers: int = 0 #copyPurchaseUsernumber # Conversion rate (CVR)Metrics click_through_rate: float = 0.0 # CTR (clicks/exposures) view_rate: float = 0.0 #queryrate (views/clicks) cart_rate: float = 0.0 #Conversion rate (CVR) (add_carts/views) purchase_rate: float = 0.0 #PurchaseConversion rate (CVR) (purchases/views) # degreeandtrend popularity_score: float = 0.0 #minutenumber trend_score: float = 0.0 #trendminutenumber (up/down) velocity: float = 0.0 #increasedegree # total_revenue: float = 0.0 #total avg_selling_price: float = 0.0 #averageprice stock_turnover: float = 0.0 #inventoryweekrate class MultiWindowStatsCalculator: """multipleTime windowStatistical featuresCompute/Calculate""" def __init__(self, redis_config: Dict = None): self.redis_config = redis_config or { 'host': 'localhost', 'port': 6379, 'db': 0 } # Time windowConfiguration(second) self.window_seconds = { TimeWindow.ONE_DAY: 24 * 3600, #1day TimeWindow.THREE_DAYS: 3 * 24 * 3600, #3day TimeWindow.ONE_WEEK: 7 * 24 * 3600, #7day TimeWindow.TWO_WEEKS: 14 * 24 * 3600, #2week TimeWindow.ONE_MONTH: 30 * 24 * 3600 #1individualmonth } # BehaviorCache self.user_events = defaultdict(deque) # user_id -> events self.item_events = defaultdict(deque) # item_id -> events async def record_behavior_event(self, event: Dict[str, Any]): """recordUserBehavior""" user_id = event.get('user_id') item_id = event.get('item_id') timestamp = event.get('timestamp', time.time()) # addtoUserteam if user_id: self.user_events[user_id].append(event) # teamlargesmall(mostmultiple1individualmonth number) await self._cleanup_old_events(self.user_events[user_id], timestamp) # addtoProductteam if item_id: self.item_events[item_id].append(event) await self._cleanup_old_events(self.item_events[item_id], timestamp) async def _cleanup_old_events(self, event_queue: deque, current_time: float): """Cleanthrough(through1individualmonth)""" cutoff_time = current_time - self.window_seconds[TimeWindow.ONE_MONTH] while event_queue and event_queue[0].get('timestamp', 0) < cutoff_time: event_queue.popleft() async def calculate_user_stats(self, user_id: str, windows: List[TimeWindow] = None) -> Dict[TimeWindow, UserBehaviorStats]: """Compute/CalculateUsermultipleTime windowStatistical features""" if windows is None: windows = list(TimeWindow) current_time = time.time() user_events = self.user_events.get(user_id, deque()) stats_by_window = {} for window in windows: cutoff_time = current_time - self.window_seconds[window] # selectTime windowinner window_events = [ event for event in user_events if event.get('timestamp', 0) >= cutoff_time ] # Compute/CalculateStatistical features stats = await self._calculate_user_window_stats( user_id, window, window_events, current_time ) stats_by_window[window] = stats return stats_by_window async def _calculate_user_window_stats(self, user_id: str, window: TimeWindow, events: List[Dict], current_time: float) -> UserBehaviorStats: """Compute/CalculateindividualTime window User""" stats = UserBehaviorStats( user_id=user_id, window=window, timestamp=current_time ) if not events: return stats # BehaviorclassmodelGroup behavior_counts = defaultdict(int) session_durations = [] unique_items = set() unique_categories = set() daily_sessions = defaultdict(set) # date -> session_ids order_values = [] category_counts = defaultdict(int) brand_counts = defaultdict(int) price_values = [] for event in events: action = event.get('action', 'unknown') behavior_counts[action] += 1 # Productandclass if 'item_id' in event: unique_items.add(event['item_id']) if 'category_id' in event: unique_categories.add(event['category_id']) category_counts[event['category_id']] += 1 if 'brand_id' in event: brand_counts[event['brand_id']] += 1 if 'price' in event: price_values.append(event['price']) # Session if 'session_id' in event and 'session_duration' in event: session_durations.append(event['session_duration']) # dateGroupSession event_date = datetime.fromtimestamp(event.get('timestamp', 0)).date() daily_sessions[event_date].add(event['session_id']) # orderpricevalue if action == 'purchase' and 'order_value' in event and event['order_value'] is not None: order_values.append(event['order_value']) # Behavior stats.page_views = behavior_counts.get('view', 0) stats.clicks = behavior_counts.get('click', 0) stats.searches = behavior_counts.get('search', 0) stats.add_carts = behavior_counts.get('add_cart', 0) stats.purchases = behavior_counts.get('purchase', 0) stats.likes = behavior_counts.get('like', 0) stats.shares = behavior_counts.get('share', 0) # hour if session_durations: stats.total_browse_time = sum(session_durations) stats.avg_session_duration = np.mean(session_durations) stats.max_session_duration = max(session_durations) # degreeBehavior stats.unique_items_viewed = len(unique_items) stats.unique_categories = len(unique_categories) stats.repeat_purchases = max(0, stats.purchases - len(set( event.get('item_id') for event in events if event.get('action') == 'purchase' ))) # Conversion rate (CVR)Compute/Calculate if stats.page_views > 0: stats.click_rate = stats.clicks / stats.page_views if stats.clicks > 0: stats.cart_conversion_rate = stats.add_carts / stats.clicks stats.purchase_conversion_rate = stats.purchases / stats.clicks # degree stats.active_days = len(daily_sessions) stats.active_sessions = sum(len(sessions) for sessions in daily_sessions.values()) if stats.active_days > 0: stats.avg_daily_sessions = stats.active_sessions / stats.active_days # cost if order_values: stats.total_amount = sum(order_values) stats.avg_order_value = np.mean(order_values) stats.max_order_value = max(order_values) # good(Top3) stats.preferred_categories = sorted(category_counts.items(), key=lambda x: x[1], reverse=True)[:3] stats.preferred_categories = [cat for cat, _ in stats.preferred_categories] stats.preferred_brands = sorted(brand_counts.items(), key=lambda x: x[1], reverse=True)[:3] stats.preferred_brands = [brand for brand, _ in stats.preferred_brands] if price_values: stats.preferred_price_range = (min(price_values), max(price_values)) return stats async def calculate_item_stats(self, item_id: str, windows: List[TimeWindow] = None) -> Dict[TimeWindow, ItemBehaviorStats]: """Compute/CalculateProductmultipleTime windowStatistical features""" if windows is None: windows = list(TimeWindow) current_time = time.time() item_events = self.item_events.get(item_id, deque()) stats_by_window = {} for window in windows: cutoff_time = current_time - self.window_seconds[window] # selectTime windowinner window_events = [ event for event in item_events if event.get('timestamp', 0) >= cutoff_time ] # Compute/CalculateStatistical features stats = await self._calculate_item_window_stats( item_id, window, window_events, current_time ) stats_by_window[window] = stats return stats_by_window async def _calculate_item_window_stats(self, item_id: str, window: TimeWindow, events: List[Dict], current_time: float) -> ItemBehaviorStats: """Compute/CalculateindividualTime window Product""" stats = ItemBehaviorStats( item_id=item_id, window=window, timestamp=current_time ) if not events: return stats # BehaviorclassmodelGroup behavior_counts = defaultdict(int) unique_users = set() buyers = set() repeat_buyers = defaultdict(int) revenues = [] prices = [] for event in events: action = event.get('action', 'unknown') behavior_counts[action] += 1 user_id = event.get('user_id') if user_id: unique_users.add(user_id) if action == 'purchase': buyers.add(user_id) repeat_buyers[user_id] += 1 if 'order_value' in event and event['order_value'] is not None: revenues.append(event['order_value']) if 'price' in event: prices.append(event['price']) # dynamic stats.exposures = behavior_counts.get('exposure', 0) stats.views = behavior_counts.get('view', 0) stats.clicks = behavior_counts.get('click', 0) stats.add_carts = behavior_counts.get('add_cart', 0) stats.purchases = behavior_counts.get('purchase', 0) stats.likes = behavior_counts.get('like', 0) stats.shares = behavior_counts.get('share', 0) # Userdegree stats.unique_viewers = len(unique_users) stats.unique_buyers = len(buyers) stats.repeat_buyers = len([user for user, count in repeat_buyers.items() if count > 1]) # Conversion rate (CVR)Compute/Calculate if stats.exposures > 0: stats.click_through_rate = stats.clicks / stats.exposures if stats.clicks > 0: stats.view_rate = stats.views / stats.clicks if stats.views > 0: stats.cart_rate = stats.add_carts / stats.views stats.purchase_rate = stats.purchases / stats.views # degreeandtrendCompute/Calculate(simplified) stats.popularity_score = min(1.0, stats.unique_viewers / 1000.0) #Standardizationto0-1 # Compute/Calculatetrend(withfrontindividualforratio) prev_window_events = [ event for event in events if event.get('timestamp', 0) >= current_time - 2 * self.window_seconds[window] and event.get('timestamp', 0) < current_time - self.window_seconds[window] ] if prev_window_events: prev_views = len([e for e in prev_window_events if e.get('action') == 'view']) current_views = stats.views if prev_views > 0: stats.trend_score = (current_views - prev_views) / prev_views stats.velocity = current_views / len(prev_window_events) if prev_window_events else 0 # if revenues: stats.total_revenue = sum(revenues) stats.avg_selling_price = np.mean(prices) if prices else 0 return stats async def get_feature_vector(self, user_id: str, item_id: str = None, windows: List[TimeWindow] = None) -> Dict[str, float]: """GetFeaturesVector(machine learningModel)""" if windows is None: windows = [TimeWindow.ONE_DAY, TimeWindow.ONE_WEEK, TimeWindow.ONE_MONTH] feature_vector = {} # UserStatistical features user_stats = await self.calculate_user_stats(user_id, windows) for window, stats in user_stats.items(): prefix = f"user_{window.value}_" feature_vector.update({ f"{prefix}page_views": float(stats.page_views), f"{prefix}clicks": float(stats.clicks), f"{prefix}purchases": float(stats.purchases), f"{prefix}click_rate": stats.click_rate, f"{prefix}purchase_rate": stats.purchase_conversion_rate, f"{prefix}avg_order_value": stats.avg_order_value, f"{prefix}active_days": float(stats.active_days), f"{prefix}unique_items": float(stats.unique_items_viewed), f"{prefix}avg_session_duration": stats.avg_session_duration }) # ProductStatistical features if item_id: item_stats = await self.calculate_item_stats(item_id, windows) for window, stats in item_stats.items(): prefix = f"item_{window.value}_" feature_vector.update({ f"{prefix}views": float(stats.views), f"{prefix}clicks": float(stats.clicks), f"{prefix}purchases": float(stats.purchases), f"{prefix}ctr": stats.click_through_rate, f"{prefix}purchase_rate": stats.purchase_rate, f"{prefix}popularity": stats.popularity_score, f"{prefix}trend": stats.trend_score, f"{prefix}unique_viewers": float(stats.unique_viewers) }) return feature_vector async def cache_stats_to_redis(self, stats_dict: Dict, cache_key: str, ttl: int = 3600): """willresultCachetoRedis""" try: r = redis.Redis(**self.redis_config, decode_responses=True) # serializenumber serialized_stats = {} for window, stats in stats_dict.items(): if hasattr(stats, '__dict__'): serialized_stats[window.value] = json.dumps(stats.__dict__) else: serialized_stats[window.value] = json.dumps(stats) # batchamountWriteRedis pipe = r.pipeline() pipe.hset(cache_key, mapping=serialized_stats) pipe.expire(cache_key, ttl) pipe.execute() except Exception as e: print(f"CachenumberFailure: {e}") # demoandTestfunction async def demonstrate_multi_window_stats(): """demomultipleTime window""" print("=" * 80) print("multipleTime windowStatistical featuressystemdemo") print("Time window: 1day/3day/7day/2week/1individualmonth") print("=" * 80) calculator = MultiWindowStatsCalculator() # mock/simulateUserBehavior print("\n🎯 Generatemock/simulateUserBehavior...") current_time = time.time() # Generatehour sample_events = [] for days_ago in [0, 1, 3, 7, 14, 25]: #daynumberfront event_time = current_time - (days_ago * 24 * 3600) # forindividualhourpointGeneratemultipleindividual for i in range(5): event = { 'user_id': 'user_001', 'item_id': f'item_{100 + i}', 'action': np.random.choice(['view', 'click', 'add_cart', 'purchase'], p=[0.5, 0.3, 0.15, 0.05]), 'timestamp': event_time + i * 60, #1minute 'session_id': f'session_{days_ago}_{i}', 'session_duration': np.random.randint(30, 600), #30secondto10minute 'category_id': np.random.randint(1, 6), 'brand_id': np.random.randint(1, 21), 'price': np.random.uniform(10, 500), 'order_value': np.random.uniform(50, 1000) if np.random.random() < 0.1 else None } sample_events.append(event) print(f"Generate {len(sample_events)} individualmock/simulate") # record for event in sample_events: await calculator.record_behavior_event(event) # Compute/CalculateUser print("\n📊 Compute/CalculateUsermultipleTime windowStatistical features...") user_stats = await calculator.calculate_user_stats('user_001') print("\nUserBehaviorresult:") print("-" * 60) for window, stats in user_stats.items(): print(f"\n📅 {window.value} :") print(f"surface: {stats.page_views}") print(f"Clicknumber: {stats.clicks}") print(f"Purchasenumber: {stats.purchases}") print(f"Click-through rate (CTR): {stats.click_rate:.3f}") print(f"PurchaseConversion rate (CVR): {stats.purchase_conversion_rate:.3f}") print(f"daynumber: {stats.active_days}") print(f"Productnumber: {stats.unique_items_viewed}") print(f"averageSessionhour: {stats.avg_session_duration:.1f}second") if stats.total_amount > 0: print(f"totalcost: ¥{stats.total_amount:.2f}") print(f"averageorderpricevalue: ¥{stats.avg_order_value:.2f}") # Compute/CalculateProduct print("\n🛍️ Compute/CalculateProductmultipleTime windowStatistical features...") item_stats = await calculator.calculate_item_stats('item_100') print("\nProductBehaviorresult:") print("-" * 60) for window, stats in item_stats.items(): print(f"\n📅 {window.value} :") print(f"Product: {stats.views}") print(f"Clicknumber: {stats.clicks}") print(f"Purchasenumber: {stats.purchases}") print(f"visitor: {stats.unique_viewers}") if stats.views > 0: print(f"PurchaseConversion rate (CVR): {stats.purchase_rate:.3f}") print(f"minutenumber: {stats.popularity_score:.3f}") print(f"trendminutenumber: {stats.trend_score:.3f}") # GenerateFeaturesVector print("\n🧮 Generatemachine learningFeaturesVector...") feature_vector = await calculator.get_feature_vector('user_001', 'item_100') print("\nFeaturesVectorkind (front20individualFeatures):") print("-" * 60) for i, (feature_name, value) in enumerate(list(feature_vector.items())[:20]): print(f" {feature_name}: {value:.3f}") print(f"\ntotalFeaturesdegree: {len(feature_vector)}") # Cachedemo print("\n💾 CacheresulttoRedis...") try: await calculator.cache_stats_to_redis( user_stats, f"user_stats:user_001", ttl=3600 ) print("✅ UserCacheSuccess") await calculator.cache_stats_to_redis( item_stats, f"item_stats:item_100", ttl=3600 ) print("✅ ProductCacheSuccess") except Exception as e: print(f"⚠️ CacheFailure (RedisStart): {e}") print("\n" + "=" * 80) print("multipleTime windowStatistical featuressystemdemoComplete！") print("system:") print("✅ 1day/3day/7day/2week/1individualmonth multipleTime window") print("✅ UserBehaviorFeatures + ProductdegreeFeatures") print("✅ Real-timeCompute/Calculate + RedisCache") print("✅ machine learningFeaturesVectorGenerate") print("=" * 80) if __name__ == "__main__": asyncio.run(demonstrate_multi_window_stats())