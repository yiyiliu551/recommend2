""" Enhanced Feature Engineering with Multi-Time Window Statistics Advanced feature engineering - Integrated multi-time window statistical features Supports: 1day/3days/7days/2weeks/1month time window statistics Author: Yang Liu """ import numpy as np import pandas as pd import time from typing import Dict, List, Tuple, Optional, Any from dataclasses import dataclass, field from datetime import datetime, timedelta from collections import defaultdict import json from multi_window_statistics import MultiWindowStatsCalculator, TimeWindow @dataclass class EnhancedUserFeatures: """Enhanced user features - integrated multi-time window statistics""" user_id: str # Basic user profile age_group: int = 0 gender: int = 0 city_level: int = 0 registration_days: int = 0 # 1-day window features clicks_1d: int = 0 purchases_1d: int = 0 browse_time_1d: int = 0 unique_items_1d: int = 0 click_rate_1d: float = 0.0 purchase_rate_1d: float = 0.0 avg_order_value_1d: float = 0.0 # 3-day window features clicks_3d: int = 0 purchases_3d: int = 0 browse_time_3d: int = 0 unique_items_3d: int = 0 click_rate_3d: float = 0.0 purchase_rate_3d: float = 0.0 avg_order_value_3d: float = 0.0 # 7-day window features clicks_7d: int = 0 purchases_7d: int = 0 browse_time_7d: int = 0 unique_items_7d: int = 0 click_rate_7d: float = 0.0 purchase_rate_7d: float = 0.0 avg_order_value_7d: float = 0.0 # 2-week window features clicks_14d: int = 0 purchases_14d: int = 0 browse_time_14d: int = 0 unique_items_14d: int = 0 click_rate_14d: float = 0.0 purchase_rate_14d: float = 0.0 avg_order_value_14d: float = 0.0 # 1-month window features clicks_30d: int = 0 purchases_30d: int = 0 browse_time_30d: int = 0 unique_items_30d: int = 0 click_rate_30d: float = 0.0 purchase_rate_30d: float = 0.0 avg_order_value_30d: float = 0.0 # Trend features (time series changes) click_trend_3d_1d: float = 0.0 # 3day vs 1day click trend click_trend_7d_3d: float = 0.0 # 7day vs 3day click trend click_trend_30d_7d: float = 0.0 # 30day vs 7day click trend purchase_trend_7d_1d: float = 0.0 # 7day vs 1day purchase trend purchase_trend_30d_7d: float = 0.0 # 30day vs 7day purchase trend # Behavior activity features active_days_ratio_7d: float = 0.0 # Active days ratio within 7 days active_days_ratio_30d: float = 0.0 # Active days ratio within 30 days # User type classification features user_activity_level: str = "normal" # low, normal, high, super user_purchase_power: str = "medium" # low, medium, high, luxury user_exploration_level: float = 0.0 # Exploration diversity score @dataclass class EnhancedItemFeatures: """Enhanced item features - integrated multi-time window statistics""" item_id: str # Basic item attributes category_id: int = 0 brand_id: int = 0 price: float = 0.0 is_new_item: bool = False # 1-day window features views_1d: int = 0 clicks_1d: int = 0 purchases_1d: int = 0 ctr_1d: float = 0.0 cvr_1d: float = 0.0 unique_viewers_1d: int = 0 # 3-day window features views_3d: int = 0 clicks_3d: int = 0 purchases_3d: int = 0 ctr_3d: float = 0.0 cvr_3d: float = 0.0 unique_viewers_3d: int = 0 # 7-day window features views_7d: int = 0 clicks_7d: int = 0 purchases_7d: int = 0 ctr_7d: float = 0.0 cvr_7d: float = 0.0 unique_viewers_7d: int = 0 # 2-week window features views_14d: int = 0 clicks_14d: int = 0 purchases_14d: int = 0 ctr_14d: float = 0.0 cvr_14d: float = 0.0 unique_viewers_14d: int = 0 # 1-month window features views_30d: int = 0 clicks_30d: int = 0 purchases_30d: int = 0 ctr_30d: float = 0.0 cvr_30d: float = 0.0 unique_viewers_30d: int = 0 # Popularity trend features view_trend_3d_1d: float = 0.0 # 3day vs 1day view trend view_trend_7d_3d: float = 0.0 # 7day vs 3day view trend view_trend_30d_7d: float = 0.0 # 30day vs 7day view trend purchase_trend_7d_1d: float = 0.0 # 7day vs 1day purchase trend purchase_trend_30d_7d: float = 0.0 # 30day vs 7day purchase trend # Item lifecycle features item_maturity_stage: str = "growth" # introduction, growth, maturity, decline popularity_level: str = "normal" # low, normal, high, viral seasonality_score: float = 0.0 # Seasonality score # Competitiveness features category_rank_7d: int = 0 # Category ranking within 7 days category_rank_30d: int = 0 # Category ranking within 30 days price_competitiveness: float = 0.0 # Price competitiveness class EnhancedFeatureEngineer: """Enhanced feature engineer - integrated multi-time window statistics""" def __init__(self): self.stats_calculator = MultiWindowStatsCalculator() self.time_windows = [ TimeWindow.ONE_DAY, TimeWindow.THREE_DAYS, TimeWindow.ONE_WEEK, TimeWindow.TWO_WEEKS, TimeWindow.ONE_MONTH ] async def extract_enhanced_user_features(self, user_id: str, base_features: Dict = None) -> EnhancedUserFeatures: """Extract enhanced user features""" # Get multi-time window statistics user_stats = await self.stats_calculator.calculate_user_stats( user_id, self.time_windows ) # Initialize enhanced features features = EnhancedUserFeatures(user_id=user_id) # Fill basic features if base_features: features.age_group = base_features.get('age_group', 0) features.gender = base_features.get('gender', 0) features.city_level = base_features.get('city_level', 0) features.registration_days = base_features.get('registration_days', 0) # Fill multi-time window statistical features for window, stats in user_stats.items(): window_suffix = window.value # Set features for corresponding time window setattr(features, f'clicks_{window_suffix}', stats.clicks) setattr(features, f'purchases_{window_suffix}', stats.purchases) setattr(features, f'browse_time_{window_suffix}', stats.total_browse_time) setattr(features, f'unique_items_{window_suffix}', stats.unique_items_viewed) setattr(features, f'click_rate_{window_suffix}', stats.click_rate) setattr(features, f'purchase_rate_{window_suffix}', stats.purchase_conversion_rate) setattr(features, f'avg_order_value_{window_suffix}', stats.avg_order_value) # Calculate trend features features.click_trend_3d_1d = self._calculate_trend( features.clicks_3d, features.clicks_1d, 3 ) features.click_trend_7d_3d = self._calculate_trend( features.clicks_7d, features.clicks_3d, 7/3 ) features.click_trend_30d_7d = self._calculate_trend( features.clicks_30d, features.clicks_7d, 30/7 ) features.purchase_trend_7d_1d = self._calculate_trend( features.purchases_7d, features.purchases_1d, 7 ) features.purchase_trend_30d_7d = self._calculate_trend( features.purchases_30d, features.purchases_7d, 30/7 ) # Calculate activity ratio stats_7d = user_stats.get(TimeWindow.ONE_WEEK) stats_30d = user_stats.get(TimeWindow.ONE_MONTH) if stats_7d: features.active_days_ratio_7d = stats_7d.active_days / 7.0 if stats_30d: features.active_days_ratio_30d = stats_30d.active_days / 30.0 # User classification features.user_activity_level = self._classify_activity_level(features) features.user_purchase_power = self._classify_purchase_power(features) features.user_exploration_level = self._calculate_exploration_level(features) return features async def extract_enhanced_item_features(self, item_id: str, base_features: Dict = None) -> EnhancedItemFeatures: """Extract enhanced item features""" # Get multi-time window statistics item_stats = await self.stats_calculator.calculate_item_stats( item_id, self.time_windows ) # Initialize enhanced features features = EnhancedItemFeatures(item_id=item_id) # Fill basic features if base_features: features.category_id = base_features.get('category_id', 0) features.brand_id = base_features.get('brand_id', 0) features.price = base_features.get('price', 0.0) features.is_new_item = base_features.get('is_new_item', False) # Fill multi-time window statistical features for window, stats in item_stats.items(): window_suffix = window.value setattr(features, f'views_{window_suffix}', stats.views) setattr(features, f'clicks_{window_suffix}', stats.clicks) setattr(features, f'purchases_{window_suffix}', stats.purchases) setattr(features, f'ctr_{window_suffix}', stats.click_through_rate) setattr(features, f'cvr_{window_suffix}', stats.purchase_rate) setattr(features, f'unique_viewers_{window_suffix}', stats.unique_viewers) # Calculate trend features features.view_trend_3d_1d = self._calculate_trend( features.views_3d, features.views_1d, 3 ) features.view_trend_7d_3d = self._calculate_trend( features.views_7d, features.views_3d, 7/3 ) features.view_trend_30d_7d = self._calculate_trend( features.views_30d, features.views_7d, 30/7 ) features.purchase_trend_7d_1d = self._calculate_trend( features.purchases_7d, features.purchases_1d, 7 ) features.purchase_trend_30d_7d = self._calculate_trend( features.purchases_30d, features.purchases_7d, 30/7 ) # Item classification features.item_maturity_stage = self._classify_maturity_stage(features) features.popularity_level = self._classify_popularity_level(features) features.seasonality_score = self._calculate_seasonality_score(features) return features def _calculate_trend(self, longer_period_value: float, shorter_period_value: float, time_ratio: float) -> float: """Calculate trend change rate""" if shorter_period_value == 0: return 0.0 # Normalize to the same time scale normalized_longer = longer_period_value / time_ratio # Calculate change rate trend = (normalized_longer - shorter_period_value) / shorter_period_value return max(-1.0, min(1.0, trend)) # Limit to [-1, 1] range def _classify_activity_level(self, user_features: EnhancedUserFeatures) -> str: """Classify user activity level""" daily_clicks = user_features.clicks_7d / 7.0 if daily_clicks >= 20: return "super" elif daily_clicks >= 10: return "high" elif daily_clicks >= 3: return "normal" else: return "low" def _classify_purchase_power(self, user_features: EnhancedUserFeatures) -> str: """Classify user purchase power""" avg_order_value = user_features.avg_order_value_30d if avg_order_value >= 1000: return "luxury" elif avg_order_value >= 500: return "high" elif avg_order_value >= 100: return "medium" else: return "low" def _calculate_exploration_level(self, user_features: EnhancedUserFeatures) -> float: """Calculate user exploration diversity""" if user_features.clicks_30d == 0: return 0.0 # Based on browsing item diversity exploration = user_features.unique_items_30d / max(user_features.clicks_30d, 1) return min(1.0, exploration) def _classify_maturity_stage(self, item_features: EnhancedItemFeatures) -> str: """Classify item lifecycle stage""" view_trend = item_features.view_trend_30d_7d if item_features.is_new_item: return "introduction" elif view_trend > 0.2: return "growth" elif -0.2 <= view_trend <= 0.2: return "maturity" else: return "decline" def _classify_popularity_level(self, item_features: EnhancedItemFeatures) -> str: """Classify item popularity level""" daily_views = item_features.views_7d / 7.0 if daily_views >= 1000: return "viral" elif daily_views >= 100: return "high" elif daily_views >= 10: return "normal" else: return "low" def _calculate_seasonality_score(self, item_features: EnhancedItemFeatures) -> float: """Calculate seasonality score (simplified version)""" # Calculate seasonality based on change rates of different time windows short_term_trend = item_features.view_trend_7d_3d long_term_trend = item_features.view_trend_30d_7d # Seasonal items usually have larger cyclical fluctuations volatility = abs(short_term_trend - long_term_trend) return min(1.0, volatility) async def create_combined_features(self, user_id: str, item_id: str, context: Dict = None) -> Dict[str, float]: """Create user-item combined feature vector""" # Get enhanced user and item features user_features = await self.extract_enhanced_user_features(user_id) item_features = await self.extract_enhanced_item_features(item_id) # Merge features feature_dict = {} # User features user_dict = user_features.__dict__ for key, value in user_dict.items(): if isinstance(value, (int, float)): feature_dict[f"user_{key}"] = float(value) elif isinstance(value, str): # Categorical feature encoding feature_dict[f"user_{key}_encoded"] = float(hash(value) % 100) # Item features item_dict = item_features.__dict__ for key, value in item_dict.items(): if isinstance(value, (int, float)): feature_dict[f"item_{key}"] = float(value) elif isinstance(value, str): feature_dict[f"item_{key}_encoded"] = float(hash(value) % 100) # Interaction features feature_dict["user_item_activity_match"] = ( user_features.user_activity_level == item_features.popularity_level ) feature_dict["user_item_trend_alignment"] = ( user_features.click_trend_7d_3d * item_features.view_trend_7d_3d ) # Context features if context: current_hour = context.get('hour', 12) current_weekday = context.get('weekday', 1) feature_dict["context_hour"] = float(current_hour) feature_dict["context_weekday"] = float(current_weekday) feature_dict["context_is_weekend"] = float(current_weekday >= 5) return feature_dict # demofunction async def demonstrate_enhanced_features(): """Demonstrate enhanced feature engineering""" print("=" * 80) print("Enhanced Feature Engineering Demonstration") print("Multi-time window statistical features: 1day/3days/7days/2weeks/1month") print("=" * 80) engineer = EnhancedFeatureEngineer() # Simulate user and item behavior data print("\nðŸŽ¯ Generating simulated behavior data...") # Generate user behavior events current_time = time.time() events = [] for days_ago in range(35): # 35 days of historical data for _ in range(np.random.poisson(5)): # Average 5 events per day event = { 'user_id': 'user_001', 'item_id': f'item_{np.random.randint(1, 21)}', 'action': np.random.choice(['view', 'click', 'add_cart', 'purchase'], p=[0.5, 0.3, 0.15, 0.05]), 'timestamp': current_time - days_ago * 24 * 3600 + np.random.randint(0, 24*3600), 'session_id': f'session_{days_ago}_{np.random.randint(1, 4)}', 'session_duration': np.random.randint(30, 1200), 'category_id': np.random.randint(1, 6), 'brand_id': np.random.randint(1, 11), 'price': np.random.uniform(20, 800), 'order_value': np.random.uniform(50, 1000) if np.random.random() < 0.1 else None } events.append(event) # Record events for event in events: await engineer.stats_calculator.record_behavior_event(event) print(f"Generated and recorded {len(events)} behavior events") # Extract enhanced user features print("\nðŸ‘¤ Extracting enhanced user features...") user_features = await engineer.extract_enhanced_user_features( 'user_001', base_features={ 'age_group': 3, 'gender': 1, 'city_level': 2, 'registration_days': 365 } ) print("\nEnhanced User Features:") print("-" * 60) print(f"Basic profile: Age group {user_features.age_group}, Gender {user_features.gender}, Tier-{user_features.city_level} city") print(f"Registration days: {user_features.registration_days} days") print() print("Multi-time window click statistics:") print(f" 1day: {user_features.clicks_1d}, 3days: {user_features.clicks_3d}, 7days: {user_features.clicks_7d}") print(f" 2weeks: {user_features.clicks_14d}, 1month: {user_features.clicks_30d}") print() print("Multi-time window purchase statistics:") print(f" 1day: {user_features.purchases_1d}, 3days: {user_features.purchases_3d}, 7days: {user_features.purchases_7d}") print(f" 2weeks: {user_features.purchases_14d}, 1month: {user_features.purchases_30d}") print() print("Conversion rate statistics:") print(f" 1day click rate: {user_features.click_rate_1d:.3f}, purchase rate: {user_features.purchase_rate_1d:.3f}") print(f" 7day click rate: {user_features.click_rate_7d:.3f}, purchase rate: {user_features.purchase_rate_7d:.3f}") print(f" 30day click rate: {user_features.click_rate_30d:.3f}, purchase rate: {user_features.purchase_rate_30d:.3f}") print() print("Trend features:") print(f" Click trend (3d vs 1d): {user_features.click_trend_3d_1d:.3f}") print(f" Click trend (7d vs 3d): {user_features.click_trend_7d_3d:.3f}") print(f" Purchase trend (7d vs 1d): {user_features.purchase_trend_7d_1d:.3f}") print() print("User classification:") print(f" Activity level: {user_features.user_activity_level}") print(f" Purchase power level: {user_features.user_purchase_power}") print(f" Exploration level: {user_features.user_exploration_level:.3f}") # Extract enhanced item features print("\nðŸ›ï¸ Extracting enhanced item features...") item_features = await engineer.extract_enhanced_item_features( 'item_1', base_features={ 'category_id': 1, 'brand_id': 5, 'price': 299.99, 'is_new_item': False } ) print("\nEnhanced Item Features:") print("-" * 60) print(f"Basic attributes: Category {item_features.category_id}, Brand {item_features.brand_id}, Price ${item_features.price}") print() print("Multi-time window view statistics:") print(f" 1day: {item_features.views_1d}, 3days: {item_features.views_3d}, 7days: {item_features.views_7d}") print(f" 2weeks: {item_features.views_14d}, 1month: {item_features.views_30d}") print() print("Conversion rate statistics:") print(f" 1day CTR: {item_features.ctr_1d:.3f}, CVR: {item_features.cvr_1d:.3f}") print(f" 7day CTR: {item_features.ctr_7d:.3f}, CVR: {item_features.cvr_7d:.3f}") print(f" 30day CTR: {item_features.ctr_30d:.3f}, CVR: {item_features.cvr_30d:.3f}") print() print("Trend features:") print(f" View trend (7d vs 3d): {item_features.view_trend_7d_3d:.3f}") print(f" Purchase trend (30d vs 7d): {item_features.purchase_trend_30d_7d:.3f}") print() print("Item classification:") print(f" Lifecycle stage: {item_features.item_maturity_stage}") print(f" Popularity level: {item_features.popularity_level}") print(f" Seasonality score: {item_features.seasonality_score:.3f}") # Create combined feature vector print("\nðŸ§® Creating user-item combined feature vector...") context = { 'hour': 14, 'weekday': 2 # Tuesday } combined_features = await engineer.create_combined_features( 'user_001', 'item_1', context ) print(f"\nCombined feature vector dimension: {len(combined_features)}") print("\nKey feature samples:") print("-" * 60) key_features = [ 'user_clicks_7d', 'user_purchases_7d', 'user_purchase_rate_7d', 'item_views_7d', 'item_ctr_7d', 'item_cvr_7d', 'user_item_trend_alignment', 'context_hour' ] for feature in key_features: if feature in combined_features: print(f" {feature}: {combined_features[feature]:.3f}") print("\n" + "=" * 80) print("Enhanced Feature Engineering Demonstration Completed!") print("âœ… Supports 5 time window statistical features") print("âœ… User profiles + Item attributes + Trend analysis") print("âœ… User classification + Item classification") print("âœ… Combined features + Context features") print(f"âœ… Total feature dimensions: {len(combined_features)}") print("=" * 80) if __name__ == "__main__": import asyncio asyncio.run(demonstrate_enhanced_features())