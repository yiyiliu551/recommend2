""" Online Evaluation Metrics for Recommendation System Comprehensive real-time metrics tracking for production systems Author: Yang Liu """ import time import json import logging import numpy as np from typing import Dict, List, Tuple, Optional, Any, Set from dataclasses import dataclass, field from datetime import datetime, timedelta from collections import defaultdict, deque from enum import Enum import asyncio logger = logging.getLogger(__name__) class MetricLevel(Enum): USER_LEVEL = "user" ITEM_LEVEL = "item" SESSION_LEVEL = "session" SYSTEM_LEVEL = "system" class MetricType(Enum): ENGAGEMENT = "engagement" #Userwithdegree BUSINESS = "business" #Metrics TECHNICAL = "technical" #Metrics QUALITY = "quality" #amountMetrics @dataclass class UserInteraction: """User""" user_id: str item_id: str action_type: str # impression, click, view, add_cart, purchase, like, share, dwell timestamp: float session_id: str recommendation_id: str = "" #ifisrecommend dwell_time: float = 0.0 #stophour(second) position: int = -1 #at/inrecommendList context: Dict[str, Any] = field(default_factory=dict) class OnlineMetricsCalculator: """lineupReal-timeMetricsCompute/Calculate""" def __init__(self, window_size_hours: int = 24): self.window_size = window_size_hours * 3600 #Convert/Transformforsecond # dynamicStoragenumber self.interactions: deque = deque() # minutelayerMetricsCache self.user_metrics: Dict[str, Dict] = defaultdict(dict) self.item_metrics: Dict[str, Dict] = defaultdict(dict) self.session_metrics: Dict[str, Dict] = defaultdict(dict) self.system_metrics: Dict[str, Any] = {} # Real-timenumber self.counters = defaultdict(int) self.timers = defaultdict(list) logger.info(f"Online metrics calculator initialized with {window_size_hours}h window") async def record_interaction(self, interaction: UserInteraction): """recordUserUpdateMetrics""" # addtodynamic self.interactions.append(interaction) # Cleanthroughnumber await self._cleanup_expired_data() # UpdatelayerlevelMetrics await self._update_user_metrics(interaction) await self._update_item_metrics(interaction) await self._update_session_metrics(interaction) await self._update_system_metrics(interaction) logger.debug(f"Recorded {interaction.action_type} interaction: {interaction.user_id} -> {interaction.item_id}") async def _cleanup_expired_data(self): """Cleanthrough number""" current_time = time.time() cutoff_time = current_time - self.window_size while self.interactions and self.interactions[0].timestamp < cutoff_time: self.interactions.popleft() async def _update_user_metrics(self, interaction: UserInteraction): """UpdateUserlevelMetrics""" user_id = interaction.user_id # number self.user_metrics[user_id][f'{interaction.action_type}_count'] = \ self.user_metrics[user_id].get(f'{interaction.action_type}_count', 0) + 1 # Compute/CalculateUserwithdegreeMetrics self.user_metrics[user_id].update(await self._calculate_user_engagement_metrics(user_id)) # Compute/CalculateUserpricevalueMetrics self.user_metrics[user_id].update(await self._calculate_user_business_metrics(user_id)) async def _update_item_metrics(self, interaction: UserInteraction): """UpdateProductlevelMetrics""" item_id = interaction.item_id # number self.item_metrics[item_id][f'{interaction.action_type}_count'] = \ self.item_metrics[item_id].get(f'{interaction.action_type}_count', 0) + 1 # Compute/CalculateProductdegreeMetrics self.item_metrics[item_id].update(await self._calculate_item_popularity_metrics(item_id)) # Compute/CalculateProductMetrics self.item_metrics[item_id].update(await self._calculate_item_conversion_metrics(item_id)) async def _update_session_metrics(self, interaction: UserInteraction): """UpdateSessionlevelMetrics""" session_id = interaction.session_id # Sessiondegreeanddegree session_interactions = [i for i in self.interactions if i.session_id == session_id] self.session_metrics[session_id] = { 'session_length': len(session_interactions), 'session_duration': max(i.timestamp for i in session_interactions) - min(i.timestamp for i in session_interactions) if len(session_interactions) > 1 else 0, 'unique_items_viewed': len(set(i.item_id for i in session_interactions)), 'conversion_in_session': any(i.action_type == 'purchase' for i in session_interactions), 'last_activity': interaction.timestamp } async def _update_system_metrics(self, interaction: UserInteraction): """UpdatesystemlevelMetrics""" current_time = time.time() # Updatesystemlevelnumber self.counters[f'total_{interaction.action_type}'] += 1 self.counters['total_interactions'] += 1 # Real-timeQPS minute_bucket = int(current_time // 60) self.counters[f'qps_{minute_bucket}'] += 1 # systemlevelcloseMetrics await self._calculate_system_level_metrics() # ===== lineupcenterMetricsCompute/Calculate ===== async def get_online_engagement_metrics(self, time_range_hours: int = 1) -> Dict[str, float]: """GetUserwithdegreeMetrics (lineupmostclose)""" cutoff_time = time.time() - (time_range_hours * 3600) recent_interactions = [i for i in self.interactions if i.timestamp >= cutoff_time] if not recent_interactions: return {} # centerwithdegreeMetrics total_impressions = len([i for i in recent_interactions if i.action_type == 'impression']) total_clicks = len([i for i in recent_interactions if i.action_type == 'click']) total_views = len([i for i in recent_interactions if i.action_type == 'view']) total_add_carts = len([i for i in recent_interactions if i.action_type == 'add_cart']) total_purchases = len([i for i in recent_interactions if i.action_type == 'purchase']) total_likes = len([i for i in recent_interactions if i.action_type == 'like']) # Compute/Calculatecloseratiorate ctr = total_clicks / max(total_impressions, 1) #Click-through rate (CTR) view_rate = total_views / max(total_clicks, 1) #queryrate cart_rate = total_add_carts / max(total_views, 1) #addrate purchase_rate = total_purchases / max(total_views, 1) #Purchaserate like_rate = total_likes / max(total_views, 1) #pointrate # impression_to_purchase = total_purchases / max(total_impressions, 1) #ImpressiontoPurchaseConversion rate (CVR) # Userwithdegree unique_users = len(set(i.user_id for i in recent_interactions)) avg_actions_per_user = len(recent_interactions) / max(unique_users, 1) # stophourMetrics dwell_times = [i.dwell_time for i in recent_interactions if i.dwell_time > 0] avg_dwell_time = np.mean(dwell_times) if dwell_times else 0 return { # Metrics 'ctr': ctr, #Click-through rate (CTR) (centerMetrics) 'view_rate': view_rate, #Clickbackqueryrate 'cart_rate': cart_rate, #querybackaddrate 'purchase_rate': purchase_rate, #querybackPurchaserate 'like_rate': like_rate, #querybackpointrate 'end_to_end_conversion': impression_to_purchase, #toConversion rate (CVR) # withdegreeMetrics 'avg_actions_per_user': avg_actions_per_user, #Useraveragenumber 'avg_dwell_time_seconds': avg_dwell_time, #averagestophour 'active_users': unique_users, #Usernumber # amountMetrics 'interaction_rate': (total_clicks + total_likes) / max(total_impressions, 1), #totalrate } async def get_online_business_metrics(self, time_range_hours: int = 24) -> Dict[str, float]: """GetpricevalueMetrics (ROIclose)""" cutoff_time = time.time() - (time_range_hours * 3600) recent_interactions = [i for i in self.interactions if i.timestamp >= cutoff_time] if not recent_interactions: return {} # receiveincloseMetrics (mock/simulatenumber) purchases = [i for i in recent_interactions if i.action_type == 'purchase'] total_revenue = sum(self._estimate_item_revenue(i.item_id) for i in purchases) # GMV (Gross Merchandise Value) total_impressions = len([i for i in recent_interactions if i.action_type == 'impression']) gmv_per_impression = total_revenue / max(total_impressions, 1) # ARPU (Average Revenue Per User) unique_users = len(set(i.user_id for i in recent_interactions)) purchasing_users = len(set(i.user_id for i in purchases)) arpu = total_revenue / max(unique_users, 1) arppu = total_revenue / max(purchasing_users, 1) # Average Revenue Per Paying User # Userweekpricevalueclose repeat_users = await self._calculate_repeat_users(recent_interactions) return { 'total_revenue': total_revenue, #totalreceivein 'gmv_per_impression': gmv_per_impression, #ImpressionGMV 'arpu': arpu, #averageUserreceivein 'arppu': arppu, #averagecostUserreceivein 'total_orders': len(purchases), #totalordernumber 'conversion_to_payment': len(purchases) / max(total_impressions, 1), #costConversion rate (CVR) 'repeat_user_rate': repeat_users / max(unique_users, 1), #returnrate 'avg_order_value': total_revenue / max(len(purchases), 1), #averageorderpricevalue } async def get_online_quality_metrics(self, time_range_hours: int = 6) -> Dict[str, float]: """GetrecommendamountMetrics""" cutoff_time = time.time() - (time_range_hours * 3600) recent_interactions = [i for i in self.interactions if i.timestamp >= cutoff_time and i.recommendation_id] if not recent_interactions: return {} # recommendminute position_performance = defaultdict(list) for interaction in recent_interactions: if interaction.position >= 0: is_positive = interaction.action_type in ['click', 'view', 'add_cart', 'purchase', 'like'] position_performance[interaction.position].append(1 if is_positive else 0) # Compute/Calculate position_bias = {} for pos, performances in position_performance.items(): position_bias[f'position_{pos}_ctr'] = np.mean(performances) if performances else 0 # recommendDiversityMetrics recommended_items = [i.item_id for i in recent_interactions] unique_recommendations = len(set(recommended_items)) diversity_score = unique_recommendations / max(len(recommended_items), 1) # recommendnewdegree (Userfrontthrough Productratio) novelty_score = await self._calculate_novelty_score(recent_interactions) # recommendrate (recommendmultiplefewProduct) total_available_items = await self._get_total_available_items() #mock/simulateimplementation coverage = unique_recommendations / max(total_available_items, 1) return { 'recommendation_diversity': diversity_score, #recommendDiversity 'recommendation_novelty': novelty_score, #recommendnewdegree 'catalog_coverage': coverage, #Directoryrate **position_bias, # 'avg_recommendation_score': np.mean([0.5] * len(recent_interactions)), #averagerecommendminutenumber (mock/simulate) } async def get_online_technical_metrics(self) -> Dict[str, float]: """GetperformanceMetrics""" current_minute = int(time.time() // 60) # QPS (most5minute) recent_qps = [] for i in range(5): minute_key = f'qps_{current_minute - i}' recent_qps.append(self.counters.get(minute_key, 0)) avg_qps = np.mean(recent_qps) peak_qps = max(recent_qps) # systemamount total_interactions_last_hour = sum( self.counters.get(f'qps_{current_minute - i}', 0) for i in range(60) ) return { 'current_qps': recent_qps[0], #whenfrontQPS 'avg_qps_5min': avg_qps, #5minuteaverageQPS 'peak_qps_5min': peak_qps, #5minutevalueQPS 'total_interactions_1h': total_interactions_last_hour, #1smallhourtotalnumber 'system_load': avg_qps / 1000 if avg_qps < 1000 else 1.0, #systemnegative (mock/simulate) } # ===== A/BTestcloseMetrics ===== async def get_ab_test_metrics(self, experiment_id: str, time_range_hours: int = 24) -> Dict[str, Dict[str, float]]: """GetA/BTestforratioMetrics""" cutoff_time = time.time() - (time_range_hours * 3600) recent_interactions = [i for i in self.interactions if i.timestamp >= cutoff_time] # groupGroup (mock/simulateimplementation) control_group = [i for i in recent_interactions if self._get_user_experiment_group(i.user_id) == 'control'] treatment_group = [i for i in recent_interactions if self._get_user_experiment_group(i.user_id) == 'treatment'] # minuteCompute/CalculateMetrics control_metrics = await self._calculate_group_metrics(control_group) treatment_metrics = await self._calculate_group_metrics(treatment_group) # Compute/Calculaterate improvements = {} for metric in control_metrics: control_value = control_metrics[metric] treatment_value = treatment_metrics.get(metric, 0) if control_value > 0: improvement = (treatment_value - control_value) / control_value * 100 improvements[f'{metric}_improvement_pct'] = improvement return { 'control_group': control_metrics, 'treatment_group': treatment_metrics, 'improvements': improvements } # ===== Real-timeMetrics ===== async def check_anomaly_alerts(self) -> List[Dict[str, Any]]: """CheckMetrics，GenerateReal-time""" alerts = [] # Getmost1smallhourMetrics recent_metrics = await self.get_online_engagement_metrics(time_range_hours=1) # fixedvalue thresholds = { 'ctr': {'min': 0.01, 'max': 0.15}, #CTR 'purchase_rate': {'min': 0.005, 'max': 0.08}, #Purchaserate 'avg_dwell_time_seconds': {'min': 5, 'max': 300}, #stophour } for metric, threshold in thresholds.items(): if metric in recent_metrics: value = recent_metrics[metric] if value < threshold['min']: alerts.append({ 'type': 'LOW_PERFORMANCE', 'metric': metric, 'current_value': value, 'threshold': threshold['min'], 'severity': 'HIGH' if value < threshold['min'] * 0.5 else 'MEDIUM', 'timestamp': time.time() }) elif value > threshold['max']: alerts.append({ 'type': 'ANOMALY_HIGH', 'metric': metric, 'current_value': value, 'threshold': threshold['max'], 'severity': 'MEDIUM', 'timestamp': time.time() }) return alerts # ===== auxiliarymethod ===== def _estimate_item_revenue(self, item_id: str) -> float: """Productreceivein (mock/simulateimplementation)""" # at/inactualsystem，queryProductpriceandrate item_hash = hash(item_id) % 1000 return 10 + (item_hash % 200) #10-210 Randomprice async def _calculate_repeat_users(self, interactions: List[UserInteraction]) -> int: """Compute/CalculatereturnUsernumber""" user_purchase_days = defaultdict(set) for interaction in interactions: if interaction.action_type == 'purchase': day = int(interaction.timestamp // 86400) #dayGroup user_purchase_days[interaction.user_id].add(day) # multipledayPurchase User repeat_users = sum(1 for days in user_purchase_days.values() if len(days) > 1) return repeat_users async def _calculate_novelty_score(self, interactions: List[UserInteraction]) -> float: """Compute/Calculaterecommendnewdegree""" # mock/simulateimplementation：false30% recommendforUserisnew return 0.3 async def _get_total_available_items(self) -> int: """GettotalrecommendProductnumber (mock/simulate)""" return 10000 def _get_user_experiment_group(self, user_id: str) -> str: """GetUser Group (mock/simulate)""" return 'control' if hash(user_id) % 2 == 0 else 'treatment' async def _calculate_group_metrics(self, interactions: List[UserInteraction]) -> Dict[str, float]: """Compute/Calculatefixedgroup Metrics""" if not interactions: return {} total_impressions = len([i for i in interactions if i.action_type == 'impression']) total_clicks = len([i for i in interactions if i.action_type == 'click']) total_purchases = len([i for i in interactions if i.action_type == 'purchase']) return { 'ctr': total_clicks / max(total_impressions, 1), 'purchase_rate': total_purchases / max(total_impressions, 1), 'total_interactions': len(interactions) } # ===== Compute/Calculatemethod ===== async def _calculate_user_engagement_metrics(self, user_id: str) -> Dict[str, float]: """Compute/CalculateUserwithdegreeMetrics""" user_interactions = [i for i in self.interactions if i.user_id == user_id] if not user_interactions: return {} # Userdegree unique_sessions = len(set(i.session_id for i in user_interactions)) avg_session_length = len(user_interactions) / max(unique_sessions, 1) # Usergoodfixed unique_items = len(set(i.item_id for i in user_interactions)) preference_diversity = unique_items / len(user_interactions) return { 'user_sessions': unique_sessions, 'avg_session_length': avg_session_length, 'preference_diversity': preference_diversity } async def _calculate_user_business_metrics(self, user_id: str) -> Dict[str, float]: """Compute/CalculateUserpricevalue""" user_interactions = [i for i in self.interactions if i.user_id == user_id] purchases = [i for i in user_interactions if i.action_type == 'purchase'] user_revenue = sum(self._estimate_item_revenue(i.item_id) for i in purchases) return { 'user_ltv': user_revenue, #Userweekpricevalue 'user_orders': len(purchases) } async def _calculate_item_popularity_metrics(self, item_id: str) -> Dict[str, float]: """Compute/CalculateProductdegree""" item_interactions = [i for i in self.interactions if i.item_id == item_id] if not item_interactions: return {} unique_users = len(set(i.user_id for i in item_interactions)) total_views = len([i for i in item_interactions if i.action_type == 'view']) return { 'item_unique_viewers': unique_users, 'item_total_views': total_views } async def _calculate_item_conversion_metrics(self, item_id: str) -> Dict[str, float]: """Compute/CalculateProduct""" item_interactions = [i for i in self.interactions if i.item_id == item_id] views = len([i for i in item_interactions if i.action_type == 'view']) purchases = len([i for i in item_interactions if i.action_type == 'purchase']) return { 'item_conversion_rate': purchases / max(views, 1) } async def _calculate_system_level_metrics(self): """Compute/CalculatesystemlevelMetrics""" total_interactions = self.counters['total_interactions'] self.system_metrics = { 'total_system_interactions': total_interactions, 'system_uptime_hours': 24, #mock/simulate 'active_recommendations': len(set(i.recommendation_id for i in self.interactions if i.recommendation_id)), } # ===== combineMetricstable ===== class OnlineMetricsDashboard: """lineupMetricstable""" def __init__(self, calculator: OnlineMetricsCalculator): self.calculator = calculator async def get_real_time_dashboard(self) -> Dict[str, Any]: """GetReal-timetablenumber""" # ParallelGetclassMetrics engagement_metrics = await self.calculator.get_online_engagement_metrics(time_range_hours=1) business_metrics = await self.calculator.get_online_business_metrics(time_range_hours=24) quality_metrics = await self.calculator.get_online_quality_metrics(time_range_hours=6) technical_metrics = await self.calculator.get_online_technical_metrics() # Check alerts = await self.calculator.check_anomaly_alerts() # Compute/Calculatecombineminutenumber health_score = await self._calculate_system_health_score(engagement_metrics, business_metrics) return { 'timestamp': time.time(), 'health_score': health_score, # centerMetricspiece 'key_metrics': { 'ctr': engagement_metrics.get('ctr', 0), 'conversion_rate': engagement_metrics.get('end_to_end_conversion', 0), 'revenue_per_hour': business_metrics.get('total_revenue', 0), 'active_users': engagement_metrics.get('active_users', 0), 'current_qps': technical_metrics.get('current_qps', 0) }, # Metrics 'detailed_metrics': { 'engagement': engagement_metrics, 'business': business_metrics, 'quality': quality_metrics, 'technical': technical_metrics }, # Real-time 'alerts': alerts, 'alert_count': len(alerts), 'critical_alerts': len([a for a in alerts if a.get('severity') == 'HIGH']) } async def _calculate_system_health_score(self, engagement: Dict, business: Dict) -> float: """Compute/Calculatesystemminutenumber (0-100)""" score = 100.0 # CTRdegree (Weights30%) ctr = engagement.get('ctr', 0) if ctr < 0.02: score -= 30 * (0.02 - ctr) / 0.02 # Conversion rate (CVR)degree (Weights25%) conversion = engagement.get('end_to_end_conversion', 0) if conversion < 0.01: score -= 25 * (0.01 - conversion) / 0.01 # receiveindegree (Weights25%) revenue = business.get('total_revenue', 0) expected_revenue = 1000 #dailyreceivein if revenue < expected_revenue: score -= 25 * (expected_revenue - revenue) / expected_revenue # Userdegreedegree (Weights20%) active_users = engagement.get('active_users', 0) expected_users = 100 #Usernumber if active_users < expected_users: score -= 20 * (expected_users - active_users) / expected_users return max(0, min(100, score)) # ===== exampleuse ===== async def demo_online_metrics(): """demolineupMetricssystem""" print("=" * 80) print("🌐 Online Recommendation Metrics System Demo") print("=" * 80) # InitializeMetricsCompute/Calculate calculator = OnlineMetricsCalculator(window_size_hours=24) dashboard = OnlineMetricsDashboard(calculator) # mock/simulateUsernumber print("\n📝 Simulating user interactions...") interactions = [ # User1 PurchaseBehavior UserInteraction("user_001", "item_001", "impression", time.time()-3600, "session_1", "rec_1", position=0), UserInteraction("user_001", "item_001", "click", time.time()-3550, "session_1", "rec_1", position=0), UserInteraction("user_001", "item_001", "view", time.time()-3540, "session_1", "rec_1", dwell_time=45), UserInteraction("user_001", "item_001", "add_cart", time.time()-3530, "session_1", "rec_1"), UserInteraction("user_001", "item_001", "purchase", time.time()-3520, "session_1", "rec_1"), # User2 Behavior UserInteraction("user_002", "item_002", "impression", time.time()-3400, "session_2", "rec_2", position=1), UserInteraction("user_002", "item_002", "click", time.time()-3390, "session_2", "rec_2", position=1), UserInteraction("user_002", "item_002", "view", time.time()-3380, "session_2", "rec_2", dwell_time=20), # User3 multipleProduct UserInteraction("user_003", "item_003", "impression", time.time()-3200, "session_3", "rec_3", position=0), UserInteraction("user_003", "item_004", "impression", time.time()-3190, "session_3", "rec_4", position=1), UserInteraction("user_003", "item_003", "click", time.time()-3180, "session_3", "rec_3", position=0), UserInteraction("user_003", "item_003", "like", time.time()-3170, "session_3", "rec_3"), ] # innumber for interaction in interactions: await calculator.record_interaction(interaction) print(f"Recorded {len(interactions)} interactions") # GetReal-timeMetricstable print("\n📊 Real-time metrics dashboard:") dashboard_data = await dashboard.get_real_time_dashboard() print(f"\n🏥 System Health Score: {dashboard_data['health_score']:.1f}/100") print("\n🔑 Key Metrics:") key_metrics = dashboard_data['key_metrics'] for metric, value in key_metrics.items(): print(f" - {metric}: {value:.4f}") print("\n📈 Engagement Metrics:") engagement = dashboard_data['detailed_metrics']['engagement'] for metric, value in engagement.items(): print(f" - {metric}: {value:.4f}") print("\n💰 Business Metrics:") business = dashboard_data['detailed_metrics']['business'] for metric, value in business.items(): print(f" - {metric}: {value:.2f}") # Check alerts = dashboard_data['alerts'] if alerts: print(f"\n🚨 Active Alerts ({len(alerts)}):") for alert in alerts: print(f" - {alert['severity']} {alert['type']}: {alert['metric']} = {alert['current_value']:.4f}") else: print("\n✅ No active alerts") print("\n" + "=" * 80) print("✅ Online Metrics Demo Complete!") print("=" * 80) if __name__ == "__main__": asyncio.run(demo_online_metrics())